--- ./terminal.c.orig	2012-03-22 17:33:17.000000000 -0700
+++ ./terminal.c	2012-03-22 17:58:29.000000000 -0700
@@ -51,9 +51,21 @@
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
+#if defined (_WIN32)
+# include <windows.h>
+extern int haveConsole;	/* imported from rltty.c  */
+extern HANDLE hStdout, hStdin;
+extern COORD	rlScreenEnd;
+extern int	rlScreenMax;
+#else /* !_WIN32 */
 #if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
 #  include <sys/ioctl.h>
 #endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */
+#endif /* !_WIN32 */
+
+#ifdef __MSDOS__
+# include <pc.h>
+#endif
 
 #include "rltty.h"
 #include "tcap.h"
@@ -91,9 +103,14 @@
 /*								    */
 /* **************************************************************** */
 
+#if !defined (__MSDOS__) && !defined (_WIN32)
 static char *term_buffer = (char *)NULL;
 static char *term_string_buffer = (char *)NULL;
 
+/* Non-zero means this terminal can't really do anything. */
+static int dumb_term;
+#endif /* !__MSDOS__ && !_WIN32 */
+
 static int tcap_initialized;
 
 #if !defined (__linux__)
@@ -220,6 +237,7 @@
    to the terminal.  If IGNORE_ENV is true, we do not pay attention to the
    values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being
    non-null serve to check whether or not we have initialized termcap. */
+#if !defined (_WIN32)
 void
 _rl_get_screen_size (tty, ignore_env)
      int tty, ignore_env;
@@ -264,7 +282,10 @@
       if (_rl_screenwidth <= 0)
         _rl_screenwidth = wc;
 
-#if !defined (__DJGPP__)
+#if defined (__DJGPP__)
+      if (_rl_screenwidth <= 0)
+	_rl_screenwidth = ScreenCols ();
+#else
       if (_rl_screenwidth <= 0 && term_string_buffer)
 	_rl_screenwidth = tgetnum ("co");
 #endif
@@ -280,7 +301,10 @@
       if (_rl_screenheight <= 0)
         _rl_screenheight = wr;
 
-#if !defined (__DJGPP__)
+#if defined (__DJGPP__)
+      if (_rl_screenheight <= 0)
+	_rl_screenheight = ScreenRows ();
+#else
       if (_rl_screenheight <= 0 && term_string_buffer)
 	_rl_screenheight = tgetnum ("li");
 #endif
@@ -304,6 +328,29 @@
   _rl_screenchars = _rl_screenwidth * _rl_screenheight;
 }
 
+#else	/* _WIN32*/
+
+void
+_rl_get_screen_size (tty, ignore_env)
+     int tty, ignore_env;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  
+  if ( (haveConsole & FOR_OUTPUT) &&
+       GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      _rl_screenwidth = csbi.dwSize.X;
+      _rl_screenheight = csbi.dwSize.Y;
+    }
+  else
+    {
+      _rl_screenwidth = 80;
+      _rl_screenheight = 24;
+    }
+  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
+}
+#endif	/* _WIN32  */
+
 void
 _rl_set_screen_size (rows, cols)
      int rows, cols;
@@ -360,6 +407,7 @@
     }
 }
 
+#if !defined (_WIN32)
 struct _tc_string {
      const char *tc_var;
      char **tc_value;
@@ -416,11 +464,37 @@
 #endif
   tcap_initialized = 1;
 }
+#endif /* !_WIN32 */
 
 int
 _rl_init_terminal_io (terminal_name)
      const char *terminal_name;
 {
+#if defined (_WIN32)
+  _rl_term_cr = "\r";						/* any value != 0  */
+  _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;	/* !! we emulate insertion  */
+  _rl_term_up = "y";						/* any value != 0  */
+  _rl_term_dc = _rl_term_DC =  (char *)NULL;			/* !! we emulate deletion  */
+  _rl_visible_bell = (char *)NULL;
+ 
+  _rl_get_screen_size (0, 1);
+   
+  /* Let Windows handle meta keys!  */
+  term_has_meta = 0;
+  _rl_term_mm = _rl_term_mo = (char *)NULL;
+ 
+  /* It probably has arrow keys, but I don't know what they are. */
+  _rl_term_ku = _rl_term_kd = _rl_term_kr = _rl_term_kl = (char *)NULL;
+  
+#if defined (HACK_TERMCAP_MOTION)
+  _rl_term_forward_char = (char *)NULL;
+#endif /* HACK_TERMCAP_MOTION */
+ 
+  _rl_terminal_can_insert = 0;
+  _rl_term_autowrap = 1;
+
+#else /* !_WIN32 */
+
   const char *term;
   char *buffer;
   int tty, tgetent_ret;
@@ -432,6 +506,23 @@
   if (term == 0)
     term = "dumb";
 
+#ifdef __MSDOS__
+  _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
+  _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
+  _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
+  _rl_term_mm = _rl_term_mo = (char *)NULL;
+  _rl_terminal_can_insert = term_has_meta = _rl_term_autowrap = 0;
+  _rl_term_cr = "\r";
+  _rl_term_clreol = _rl_term_clrpag = _rl_term_backspace = (char *)NULL;
+  _rl_term_goto = _rl_term_pc = _rl_term_ip = (char *)NULL;
+  _rl_term_ks = _rl_term_ke =_rl_term_vs = _rl_term_ve = (char *)NULL;
+  _rl_term_kh = _rl_term_kH = _rl_term_at7 = _rl_term_kI = (char *)NULL;
+#if defined(HACK_TERMCAP_MOTION)
+  _rl_term_forward_char = (char *)NULL;
+#endif
+
+  _rl_get_screen_size (tty, 0);
+#else  /* !__MSDOS__ */
   /* I've separated this out for later work on not calling tgetent at all
      if the calling application has supplied a custom redisplay function,
      (and possibly if the application has supplied a custom input function). */
@@ -532,6 +623,8 @@
   if (!term_has_meta)
     _rl_term_mm = _rl_term_mo = (char *)NULL;
 
+#endif /* !__MSDOS__ */
+
   /* Attempt to find and bind the arrow keys.  Do not override already
      bound keys in an overzealous attempt, however. */
 
@@ -542,9 +635,12 @@
   bind_termcap_arrow_keys (vi_insertion_keymap);
 #endif /* VI_MODE */
 
+#endif /* !_WIN32 */
+  
   return 0;
 }
 
+#if !defined (_WIN32)
 /* Bind the arrow key sequences from the termcap description in MAP. */
 static void
 bind_termcap_arrow_keys (map)
@@ -583,6 +679,7 @@
     }
   return ((char *)NULL);
 }
+#endif /* !_WIN32 */
 
 /* Re-initialize the terminal considering that the TERM/TERMCAP variable
    has changed. */
@@ -595,6 +692,7 @@
   return 0;
 }
 
+#if !defined (_WIN32)
 /* A function for the use of tputs () */
 #ifdef _MINIX
 void
@@ -628,10 +726,12 @@
 {
   register int i;
 
+#ifndef __MSDOS__
   if (_rl_term_backspace)
     for (i = 0; i < count; i++)
       tputs (_rl_term_backspace, 1, _rl_output_character_function);
   else
+#endif
     for (i = 0; i < count; i++)
       putc ('\b', _rl_out_stream);
   return 0;
@@ -661,11 +761,16 @@
 	default:
 	  break;
 	case VISIBLE_BELL:
+#ifdef __MSDOS__
+	  ScreenVisualBell ();
+	  break;
+#else
 	  if (_rl_visible_bell)
 	    {
 	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
 	      break;
 	    }
+#endif
 	  /* FALLTHROUGH */
 	case AUDIBLE_BELL:
 	  fprintf (stderr, "\007");
@@ -677,6 +782,80 @@
   return (-1);
 }
 
+#else	/* _WIN32 */
+
+/* Write COUNT characters from STRING to the output stream. */
+void
+_rl_output_some_chars (string, count)
+     const char *string;
+     int count;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  fwrite (string, 1, count, _rl_out_stream);
+  if ( (haveConsole & FOR_OUTPUT) && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      int linear_pos = (int)csbi.dwCursorPosition.Y * (int)csbi.dwSize.X
+			+ (int)csbi.dwCursorPosition.X;
+      if (linear_pos > rlScreenMax)
+        {
+          rlScreenEnd = csbi.dwCursorPosition;
+          rlScreenMax = linear_pos;
+        }
+    }
+}
+
+/* This is used to collect all putc output */
+int
+_rl_output_character_function (c)
+     int c;
+{
+  _rl_output_some_chars ((char *)&c, 1);
+  return 1;
+}
+
+/* Move the cursor back. */
+int
+_rl_backspace (count)
+     int count;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+
+  if ( (haveConsole & FOR_OUTPUT) && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      while (count > csbi.dwCursorPosition.X)
+        {
+          --csbi.dwCursorPosition.Y;
+          count -= csbi.dwCursorPosition.X + 1;
+          csbi.dwCursorPosition.X = csbi.dwSize.X - 1;
+        }
+      csbi.dwCursorPosition.X -= count;
+      SetConsoleCursorPosition(hStdout, csbi.dwCursorPosition);
+    }
+  return 0;
+}
+
+/* Move to the start of the next line. */
+int
+rl_crlf ()
+{
+  _rl_output_some_chars ("\n", 1);
+  return 0;
+}
+
+/* Ring the terminal bell. */
+int
+rl_ding ()
+{
+  if (readline_echoing_p)
+    {
+      if (_rl_bell_preference != NO_BELL)
+	MessageBeep(MB_OK);
+      return (0);
+    }
+  return (-1);
+}
+#endif	/* _WIN32 */
+
 /* **************************************************************** */
 /*								    */
 /*	 	Controlling the Meta Key and Keypad		    */
@@ -686,7 +865,7 @@
 void
 _rl_enable_meta_key ()
 {
-#if !defined (__DJGPP__)
+#if !defined (__DJGPP__) && !defined (_WIN32)
   if (term_has_meta && _rl_term_mm)
     tputs (_rl_term_mm, 1, _rl_output_character_function);
 #endif
@@ -696,7 +875,7 @@
 _rl_control_keypad (on)
      int on;
 {
-#if !defined (__DJGPP__)
+#if !defined (__DJGPP__) && !defined (_WIN32)
   if (on && _rl_term_ks)
     tputs (_rl_term_ks, 1, _rl_output_character_function);
   else if (!on && _rl_term_ke)
@@ -718,6 +897,7 @@
 _rl_set_cursor (im, force)
      int im, force;
 {
+#if !defined (__MSDOS__) && !defined (_WIN32)
   if (_rl_term_ve && _rl_term_vs)
     {
       if (force || im != rl_insert_mode)
@@ -728,4 +908,5 @@
 	    tputs (_rl_term_ve, 1, _rl_output_character_function);
 	}
     }
+#endif
 }
