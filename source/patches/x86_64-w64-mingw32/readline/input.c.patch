--- ./input.c.orig	2012-03-22 17:33:17.000000000 -0700
+++ ./input.c	2012-03-22 17:58:29.000000000 -0700
@@ -164,6 +164,7 @@
   return (push_index != pop_index);
 }
 
+#ifndef _WIN32
 /* If a character is available to be read, then read it and stuff it into
    IBUFFER.  Otherwise, just return.  Returns number of characters read
    (0 if none available) and -1 on error (EIO). */
@@ -263,6 +264,7 @@
 
   return 1;
 }
+#endif /* !_WIN32 */
 
 int
 rl_set_keyboard_input_timeout (u)
@@ -276,6 +278,7 @@
   return (o);
 }
 
+#ifndef _WIN32
 /* Is there input available to be read on the readline input file
    descriptor?  Only works if the system has select(2) or FIONREAD.
    Uses the value of _keyboard_input_timeout as the timeout; if another
@@ -320,6 +323,7 @@
 
   return 0;
 }
+#endif /* !_WIN32 */
 
 int
 _rl_input_queued (t)
@@ -448,6 +452,7 @@
   return (c);
 }
 
+#ifndef _WIN32
 int
 rl_getc (stream)
      FILE *stream;
@@ -506,6 +511,222 @@
     }
 }
 
+#else /* _WIN32 */
+
+#include <windows.h>
+#include <ctype.h>
+#include <conio.h>
+#include <io.h>
+
+#define EXT_PREFIX 0x1f8
+
+#define KEV	   irec.Event.KeyEvent			/* to make life easier  */
+#define KST	   irec.Event.KeyEvent.dwControlKeyState
+
+static int pending_key = 0;
+static int pending_count = 0;
+static int pending_prefix = 0;
+
+extern int _rl_last_c_pos;	/* imported from display.c  */
+extern int _rl_last_v_pos;
+extern int rl_dispatching;	/* imported from readline.c  */
+extern int rl_point;
+extern int rl_done;
+extern int rl_visible_prompt_length;
+extern int _rl_screenwidth;		/* imported from terminal.c  */
+
+extern int haveConsole;		/* imported from rltty.c  */
+extern HANDLE hStdout, hStdin;
+extern COORD rlScreenOrigin, rlScreenEnd;
+extern int rlScreenStart, rlScreenMax;
+static void MouseEventProc(MOUSE_EVENT_RECORD kev);
+
+int rl_getc (stream)
+     FILE *stream;
+{
+  if ( pending_count )
+    {
+      --pending_count;
+      if ( pending_prefix && (pending_count & 1) )
+        return pending_prefix;
+      else
+        return pending_key;
+    }
+
+  while ( 1 )
+    {
+      DWORD dummy;
+
+      if (WaitForSingleObject(hStdin, WAIT_FOR_INPUT) != WAIT_OBJECT_0)
+        {
+          if ( rl_done )
+            return( 0 );
+          else
+            continue;
+        }
+      if ( haveConsole & FOR_INPUT )
+        {
+          INPUT_RECORD irec;
+          ReadConsoleInput (hStdin, &irec, 1, &dummy);
+          switch(irec.EventType)
+            {
+            case KEY_EVENT:
+              if (KEV.bKeyDown &&
+                  ((KEV.wVirtualKeyCode < VK_SHIFT) ||
+                   (KEV.wVirtualKeyCode > VK_MENU)))
+                {
+                  pending_count = KEV.wRepeatCount;
+                  pending_prefix = 0;
+                  pending_key = KEV.uChar.AsciiChar & 0xff;
+
+                  if (KST & ENHANCED_KEY)
+                    {
+#define CTRL_TO_ASCII(c) ((c) - 'a' + 1)
+                      switch (KEV.wVirtualKeyCode)
+                        {
+                          case VK_HOME:
+                            pending_key = CTRL_TO_ASCII ('a');
+                            break;
+                          case VK_END:
+                            pending_key = CTRL_TO_ASCII ('e');
+                            break;
+                          case VK_LEFT:
+                            pending_key = CTRL_TO_ASCII ('b');
+                            break;
+                          case VK_RIGHT:
+                            pending_key = CTRL_TO_ASCII ('f');
+                            break;
+                          case VK_UP:
+                            pending_key = CTRL_TO_ASCII ('p');
+                            break;
+                          case VK_DOWN:
+                            pending_key = CTRL_TO_ASCII ('n');
+                            break;
+                          case VK_DELETE:
+                            pending_key = CTRL_TO_ASCII ('d');
+                            break;
+                        }
+                    }
+                  
+                  if (KST & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED))
+                    pending_prefix = VK_ESCAPE;
+
+                  if (pending_prefix)
+                      pending_count = (pending_count << 1) - 1;
+               
+                  /* Ascii direct */
+                  if (pending_key)
+                      pending_count--;
+
+                  if (pending_prefix)
+                    return pending_prefix;
+                  return pending_key;
+                }
+              break;
+            case MOUSE_EVENT:
+              if ( (haveConsole & FOR_OUTPUT) && !rl_dispatching )
+                MouseEventProc(irec.Event.MouseEvent);
+            default:
+              break;
+            }
+        }
+      else
+        {
+          int key;
+          ReadFile(hStdin, &key, 1, &dummy, NULL);
+          return key;
+        }
+    }
+}
+
+void MouseEventProc(MOUSE_EVENT_RECORD mev)
+{
+  static DWORD lastButtonState, cstat_flags;
+  static COORD lastButtonPos, src_down_pos;
+
+#define RLPOS_CHANGED	1
+#define SELECT_START	2
+  
+  switch (mev.dwEventFlags )
+    {
+    case 0 :			/* change in button state  */
+
+      /* Cursor setting: 
+	 LEFT_BUTTON_PRESSED sets cursor anywhere on the screen,
+	 thereafter, any change in button state will clipp the cursor
+	 position to the readline range if there has been no cursor
+	 movement. Otherwhise the cursor is reset to its old position.
+      */
+      if (mev.dwButtonState == FROM_LEFT_1ST_BUTTON_PRESSED)
+        {
+          if (lastButtonState == 0)
+            {
+              src_down_pos = mev.dwMousePosition;
+              cstat_flags |= RLPOS_CHANGED | SELECT_START;
+              SetConsoleCursorPosition(hStdout, mev.dwMousePosition);
+            }
+        }
+      else
+        {
+          if (cstat_flags & RLPOS_CHANGED)
+            {
+              if ( (mev.dwMousePosition.X == src_down_pos.X)
+		   && (mev.dwMousePosition.Y == src_down_pos.Y) )
+                {
+                  int linear_pos = (int)mev.dwMousePosition.Y * _rl_screenwidth
+		    + (int)mev.dwMousePosition.X;
+                  if (linear_pos < rlScreenStart + rl_visible_prompt_length)
+                    {
+                      linear_pos = rlScreenStart + rl_visible_prompt_length;
+                      mev.dwMousePosition.X = rlScreenOrigin.X + rl_visible_prompt_length;
+                      mev.dwMousePosition.Y = rlScreenOrigin.Y;
+                    }
+                  if (linear_pos > rlScreenMax)
+                    {
+                      linear_pos = rlScreenMax;
+                      mev.dwMousePosition = rlScreenEnd;
+                    }
+                  rl_point = linear_pos - rlScreenStart - rl_visible_prompt_length;
+                  _rl_last_c_pos = mev.dwMousePosition.X - rlScreenOrigin.X;
+                  _rl_last_v_pos = mev.dwMousePosition.Y - rlScreenOrigin.Y;
+                }
+              else
+                {
+                  mev.dwMousePosition.X = rlScreenOrigin.X + _rl_last_c_pos;
+                  mev.dwMousePosition.Y = rlScreenOrigin.Y + _rl_last_v_pos;
+                }
+              SetConsoleCursorPosition(hStdout, mev.dwMousePosition);
+              cstat_flags &= !RLPOS_CHANGED;
+            }
+        }
+      lastButtonState = mev.dwButtonState;
+      lastButtonPos = mev.dwMousePosition;
+      break;
+    case MOUSE_MOVED:		/* the most frequent event */
+    default:      
+      break;
+    }
+}
+
+int _rl_input_available ()
+{
+  if (isatty (fileno (rl_instream)))
+    return (kbhit());
+  return 0;
+}
+
+static int rl_gather_tyi ()
+{
+  int count = 0;
+  while (isatty (fileno (rl_instream)) && kbhit () && ibuffer_space ())
+    {
+      rl_stuff_char ((*rl_getc_function) (rl_instream));
+      count++;
+    }
+  return count;
+}
+#endif /* _WIN32 */
+
 #if defined (HANDLE_MULTIBYTE)
 /* read multibyte char */
 int
