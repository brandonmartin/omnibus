--- ./complete.c.orig	2012-03-22 17:33:17.000000000 -0700
+++ ./complete.c	2012-03-22 17:58:29.000000000 -0700
@@ -43,6 +43,11 @@
 
 #include <stdio.h>
 
+#ifdef _WIN32
+# include <windows.h>
+# include <io.h>
+#endif
+
 #include <errno.h>
 #if !defined (errno)
 extern int errno;
@@ -64,7 +69,7 @@
 #include "xmalloc.h"
 #include "rlprivate.h"
 
-#ifdef __STDC__
+#if defined (__STDC__) || defined (_WIN32)
 typedef int QSFUNC (const void *, const void *);
 #else
 typedef int QSFUNC ();
@@ -1827,6 +1832,7 @@
 /* A completion function for usernames.
    TEXT contains a partial username preceded by a random
    character (usually `~').  */
+#if 0
 char *
 rl_username_completion_function (text, state)
      const char *text;
@@ -1836,7 +1842,12 @@
   return (char *)NULL;
 #else /* !__WIN32__ && !__OPENNT) */
   static char *username = (char *)NULL;
+#ifndef _WIN32
   static struct passwd *entry;
+#else
+  char user_name[128];
+  unsigned user_len;
+#endif
   static int namelen, first_char, first_char_loc;
   char *value;
 
@@ -1849,9 +1860,12 @@
 
       username = savestring (&text[first_char_loc]);
       namelen = strlen (username);
+#ifndef _WIN32
       setpwent ();
+#endif
     }
 
+#ifndef _WIN32
 #if defined (HAVE_GETPWENT)
   while (entry = getpwent ())
     {
@@ -1881,8 +1895,100 @@
 
       return (value);
     }
+#else /* _WIN32 */
+  if (GetUserName (user_name, &user_len))
+    {
+      if (namelen == 0 || (!strnicmp (username, user_name, name_len)))
+	{
+	  value = (char *)xmalloc (2 + strlen (user_name));
+	  *value = *text;
+	  strcpy (value + first_char_loc, user_name);
+	  if (first_char == '~')
+	    rl_filename_completion_desired = 1;
+	  return (value);
+	}
+    }
+  return ((char *)NULL);
+#endif /* _WIN32 */
 #endif /* !__WIN32__ && !__OPENNT */
 }
+#endif /* 0 */
+
+char *
+rl_username_completion_function (text, state)
+     const char *text;
+     int state;
+{
+  static char *username = (char *)NULL;
+#if !defined (_WIN32)
+  static struct passwd *entry;
+#else
+  char user_name[128];
+  unsigned user_len;
+#endif
+  static int namelen, first_char, first_char_loc;
+  char *value;
+
+  if (state == 0)
+    {
+      FREE (username);
+
+      first_char = *text;
+      first_char_loc = first_char == '~';
+
+      username = savestring (&text[first_char_loc]);
+      namelen = strlen (username);
+#if !defined (_WIN32)
+      setpwent ();
+#endif
+    }
+
+#if !defined (_WIN32)
+#if defined (HAVE_GETPWENT)
+  while (entry = getpwent ())
+    {
+      /* Null usernames should result in all users as possible completions. */
+      if (namelen == 0 || (STREQN (username, entry->pw_name, namelen)))
+	break;
+    }
+#endif
+
+  if (entry == 0)
+    {
+#if defined (HAVE_GETPWENT)
+      endpwent ();
+#endif
+      return ((char *)NULL);
+    }
+  else
+    {
+      value = (char *)xmalloc (2 + strlen (entry->pw_name));
+
+      *value = *text;
+
+      strcpy (value + first_char_loc, entry->pw_name);
+
+      if (first_char == '~')
+	rl_filename_completion_desired = 1;
+
+      return (value);
+    }
+#else /* _WIN32 */
+  if (GetUserName (user_name, &user_len))
+    {
+      if (namelen == 0 || (!strnicmp (username, user_name, namelen)))
+	{
+	  value = (char *)xmalloc (2 + strlen (user_name));
+	  *value = *text;
+	  strcpy (value + first_char_loc, user_name);
+	  if (first_char == '~')
+	    rl_filename_completion_desired = 1;
+	  return (value);
+	}
+    }
+  return ((char *)NULL);
+#endif /* _WIN32 */
+}
 
 /* Okay, now we write the entry_function for filename completion.  In the
    general case.  Note that completion in the shell is a little different
@@ -1893,14 +1999,22 @@
      const char *text;
      int state;
 {
+#ifdef _WIN32
+  static WIN32_FIND_DATA entry;
+  static HANDLE directory = NULL;
+  static BOOL found = 0;
+  char tmp[MAX_PATH];
+# define DIR void
+#else
+  struct dirent *entry;
   static DIR *directory = (DIR *)NULL;
+#endif
   static char *filename = (char *)NULL;
   static char *dirname = (char *)NULL;
   static char *users_dirname = (char *)NULL;
   static int filename_len;
   char *temp;
   int dirlen;
-  struct dirent *entry;
 
   /* If we don't have any state, then do some initialization. */
   if (state == 0)
@@ -1977,7 +2091,19 @@
 	  free (users_dirname);
 	  users_dirname = temp;
 	}
+
+#ifdef _WIN32
+      strcpy (tmp, dirname);
+      if (tmp[strlen (tmp) - 1] == '/')
+	strcat (tmp, "*");
+      else
+	strcat (tmp, "/*");
+
+      directory = FindFirstFile (tmp, &entry);
+      found = 1;
+#else
       directory = opendir (dirname);
+#endif
 
       /* Now dequote a non-null filename. */
       if (filename && *filename && rl_completion_found_quote && rl_filename_dequoting_function)
@@ -1999,21 +2125,24 @@
   /* *** UNIMPLEMENTED *** */
 
   /* Now that we have some state, we can read the directory. */
-
+#ifndef _WIN32
   entry = (struct dirent *)NULL;
   while (directory && (entry = readdir (directory)))
+#else
+  while (directory != INVALID_HANDLE_VALUE && directory && found)
+#endif
     {
       /* Special case for no filename.  If the user has disabled the
          `match-hidden-files' variable, skip filenames beginning with `.'.
 	 All other entries except "." and ".." match. */
       if (filename_len == 0)
 	{
-	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (entry->d_name))
+	  if (_rl_match_hidden_files == 0 && HIDDEN_FILE (FILENAME (entry)))
 	    continue;
 
-	  if (entry->d_name[0] != '.' ||
-	       (entry->d_name[1] &&
-		 (entry->d_name[1] != '.' || entry->d_name[2])))
+	  if (FILENAME (entry)[0] != '.' ||
+	       (FILENAME (entry)[1] &&
+		 (FILENAME (entry)[1] != '.' || FILENAME (entry)[2])))
 	    break;
 	}
       else
@@ -2022,22 +2151,29 @@
 	     it is a match. */
 	  if (_rl_completion_case_fold)
 	    {
-	      if ((_rl_to_lower (entry->d_name[0]) == _rl_to_lower (filename[0])) &&
+	      if ((_rl_to_lower (FILENAME (entry)[0]) == _rl_to_lower (filename[0])) &&
 		  (((int)D_NAMLEN (entry)) >= filename_len) &&
-		  (_rl_strnicmp (filename, entry->d_name, filename_len) == 0))
+		  (_rl_strnicmp (filename, FILENAME (entry), filename_len) == 0))
 		break;
 	    }
 	  else
 	    {
-	      if ((entry->d_name[0] == filename[0]) &&
+	      if ((FILENAME (entry)[0] == filename[0]) &&
 		  (((int)D_NAMLEN (entry)) >= filename_len) &&
-		  (strncmp (filename, entry->d_name, filename_len) == 0))
+		  (strncmp (filename, FILENAME (entry), filename_len) == 0))
 		break;
 	    }
 	}
+#ifdef _WIN32
+      found = FindNextFile (directory, &entry);
+#endif
     }
 
+#ifdef _WIN32
+  if (!found)
+#else
   if (entry == 0)
+#endif
     {
       if (directory)
 	{
@@ -2090,11 +2226,14 @@
 		temp[dirlen++] = '/';
 	    }
 
-	  strcpy (temp + dirlen, entry->d_name);
+	  strcpy (temp + dirlen, FILENAME (entry));
 	}
       else
-	temp = savestring (entry->d_name);
+	temp = savestring (FILENAME (entry));
 
+#ifdef _WIN32
+      found = FindNextFile (directory, &entry);
+#endif
       return (temp);
     }
 }
